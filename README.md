# DFS (Depth-First Search): 한 경로를 끝까지 파고들며 모든 정점을 탐색한다
* `#graph`, `#recursion`, `#stack`
* 목적/해결 문제: 그래프/트리의 모든 노드를 깊이 우선으로 탐색
* 탐색 방식: 한 방향으로 끝까지 내려간 후 되돌아오며 탐색
* 사용 자료구조: 스택 (재귀 호출 또는 명시적 스택)
* 그래프 조건: 
  * 방향/무방향 그래프 모두 가능
  * 사이클 존재 시 방문 체크 필요
* 핵심 제약/특징:
  * 방문 처리 필수 (무한 루프 방지)
* 주요 활용 사례:
  * 연결 요소 탐색
  * 사이클 탐지
  * 백트랙킹, 완전탐색
  * 위상정렬
  * 트리 순회(전위/중위/후위)
* 탐색 순서 특징:
  * 시작 노드 및 인접 노드 순서에 따라 결과 달라짐
* 시간 복잡도: O(V + E)
* 공간 복잡도:
  * 재귀 스택 깊이 최대 O(V)
  * 방문 배열 O(V)

# BFS (Breadth-First Search):시작점에서 가까운 순서대로 정점을 탐색한다
* `#graph`, `#queue`, `#shortest-path`
* 목적/해결 문제: 시작 노드 기준 최단 거리(레벨) 탐색
* 탐색 방식: 가까운 노드부터 레벨 순서로 탐색
* 사용 자료구조: 큐
* 그래프 조건
  * 방향/무방향 그래프 모두 사용 가능
  * 사이클 존재 시 방문 체크 필요
* 핵심 제약/특징:
  * 큐 삽입 시점에 방문 체크
  * 간선 가중치가 동일할 때 최단 거리 보장
* 주요 활용 사례:
  * 최단 거리 문제(미로, 최소 이동 횟수)
  * 레벨 탐색(트리 높이, 거리 계산)
  * 연결 요소 탐색
  * 위상 정렬(BFS 기반, Kahn 알고리즘)
  * 상태 공간 탐색(퍼즐, 게임, 시뮬레이션)
* 탐색 순서 특징:
  * 시작 노드 기준 거리 증가 순서
* 시간 복잡도: O(V + E)
* 공간 복잡도:
  * 큐 최대 크기: O(V)
  * 방문 배열 O(V)

# 백트랙킹 (Backtracking): 모든 경우를 탐색하되 조건이 틀리면 즉시 되돌아간다
* `#dfs`, `#recursion`, `#pruning`
* 목적/해결 문제: 모든 경우 중 조건을 만족하는 해 탐색
* 탐색 방식: DFS 기반 + 조건 불만족시 즉시 중단
* 사용 자료구조: 재귀 호출 스택
* 그래프 조건:
  * 상태 공간 트리
  * 명시적 그래프가 아닌 경우가 많음
* 핵심 제약/특징:
  * 선택 -> 탐색 -> 취소(상태 복구)
  * 가지치기(Pruning)가 성능의 핵심
* 주요 활용 사례:
  * 순열/조합/부분집합
  * N-Queue
  * 스도쿠
  * 완전 탐색 최적화 문제
* 탐색 순서 특징:
  * DFS 순서
  * 조건에 따라 탐색 깊이 달라짐
* 시간 복잡도:
  * 최악: 지수 시간
* 공간 복잡도:
  * 재귀 깊이 O(탐색 깊이) 

# 다익스트라 알고리즘: 단일 출발점에서 가장 짧은 거리부터 확정해 나간다
* `#greedy`, `#priority-queue`
* 목적/해결 문제: 단일 출발점 -> 모든 노드 최단 거리
* 탐색 방식: 가장 짧은 거리 노드부터 확정
* 사용 자료구조: 우선순위 큐
* 그래프 조건:
  * 가중치 그래프
  * 음수 가중치 불가
* 핵심 제약/특징:
  * greedy + distance 갱신
* 주요 활용 사례:
  * 네비게이션
  * 네트워크 라우팅
* 탐색 순서 특징:
  * 거리 증가 순서
* 시간 복잡도:
  * O(E log V)
* 공간 복잡도
  * 거리 배열 O(V)
  * PQ O(V)

# 유니온 파인드(Disjoint Set): 원소들이 같은 집합에 속하는지 빠르게 판별한다
* `#set`, `#connectivity`
* 목적/해결 문제: 집합 관리 및 연결 여부 판단
* 탐색 방식: 루트 기반 집합 탐색
* 사용 자료구조: 배열(parent, rank/size)
* 그래프 조건:
  * 주로 무방향 그래프
* 핵심 제약/특징:
  * 경로 압축
  * rank/size 기준 union
* 주요 활용 사례:
  * 사이클 판별
  * MST
* 탐색 순서 특징:
  * 순서 개념 없음
* 시간 복잡도:
  * 거의 O(1)
* 공간 복잡도:
  * O(V)

# 크루스칼 알고리즘: 가장 비용이 작은 간선부터 선택해 모두 연결한다
* `#greedy`, `#union-find`
* 목적/해결 문제: 최소 비용으로 모든 노드 연결
* 탐색 방식: 가중치 낮은 간선부터 선택
* 사용 자료구조: 정렬 + 유니온 파인드
* 그래프 조건:
  * 무방향 그래프
* 핵심 제약/특징:
  * 사이클 금지
* 주요 활용 사례:
  * 네트워크 구축
* 탐색 순서 특징:
  * 간선 가중치 오름차순
* 시간 복잡도:
  * O(E log E)
* 공간 복잡도:
  * O(V + E)

# 위상 정렬 알고리즘: 선후 관계를 지키는 처리 순서를 만든다
* `#dependency`
* 목적/해결 문제: 선후 관계를 만족하는 순서 생성
* 탐색 방식: 진입 차수 0부터 제거
* 사용 자료구조: 큐/우선순위 큐
* 그래프 조건:
  * DAG(사이클 없음)
* 핵심 제약/특징:
  * 사이클 존재 시 불가
* 주요 활용 사례:
  * 작업 스케줄링
  * 빌드 순서
* 탐색 순서 특징:
  * 진입 차수 0 기준
* 시간 복잡도:
  * O(V + E)
* 공간 복잡도:
  * O(V)

# 동적 계획법 (Dynamic programing): 중복 계산을 제거해 최적의 답을 누적한다
* `#dp`, `#memoization`, `#optimization`
* 목적/해결 문제: 중복 계산 제거, 최적해 도출
* 탐색 방식: 작은 문제 -> 큰 문제
* 사용 자료구조: DP 테이블
* 그래프 조건:
  * 상태 전이 그래프(암묵적)
* 핵심 제약/특징:
  * 중복 부분 문제
  * 최적 부분 구조
* 주요 활용 사례:
  * 최적화 문제
  * 경우의 수
  * 문자열 문제
* 탐색 순서 특징:
  * 점화식 의존성 순서
* 시간 복잡도:
  * 상태 수 x 전이 비용
* 공간 복잡도:
  * DP 테이블 크기
