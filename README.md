# 다익스트라 알고리즘: 가장 빠른 길 찾기
* `#greedy`, `#dp`
* 단일 출발점 최단 경로: 특정 노드에서 출발하여 나머지 모든 노드로 가는 최단거리를 구한다.
* 음의 가중치 불가: 가중치의 누적을 최단 경로와 비교해 최단 경로를 갱신하기 때문에 음수의 가중치가 있으면 올바른 답을 낼 수 없다.
* 우선순위 큐: 가장 짧은 거리를 가진 노드를 빨리 찾기 위해서 우선순위 큐를 사용한다.

# 유니온 파인드(Disjoint Set): 집합을 빠르게 관리하기
* 서로소 집합 자료구조: 여러 개의 집합을 관리하며, 두 원소가 같은 집합에 속하는지 빠르게 판단한다.
* 대표 노드(루트): 각 집합은 하나의 루트 노드로 대표된다.
* Find 연산: 특정 노드가 속한 집합의 루트 노드를 찾는다.
* Union 연산: 두 노드의 루트가 서로 다를 때, 한 루트의 부모를 다른 루트로 설정해 집합을 합친다.
* 사이클 판별: 두 노드의 루트가 같다면 같은 집합이므로, 연결 시 사이클이 발생한다.
* 경로 압축: Find 과정에서 거쳐간 노드들의 부모를 루트로 직접 연결해 탐색 속도를 향상시킨다.
* Union 기준: 트리의 높이를 줄이기 위해 rank 또는 size 기준으로 루트를 합친다.
* 시간 복잡도: 경로 압축과 union 기준을 함께 사용하면 거의 O(1)에 가깝다.

# 크루스칼 알고리즘: 최소 비용으로 모두 연결하기
* `#greedy`, `#connectivity`, `#union-find`
* 최소 신장 트리(MST): 모든 노드를 연결하되, 간선 가중치의 합이 최소가 되도록 한다.
* 간선 중심 알고리즘: 노드가 아니라 간선을 기준으로 선택을 진행한다.
* 사이클 금지: 이미 같은 집합에 속한 두 노드를 연결하는 간선은 선택하지 않는다.
* 가중치 정렬: 모든 간선을 가중치 오름차순으로 정렬한 뒤 순서대로 선택한다.(정렬 또는 우선순위 큐 사용)
* 유니온 파인드: 사이클 여부를 빠르게 판단하기 위해 Disjoint Set(Union-Find)을 사용한다.
* 종료 조건: 선택한 간선의 개수가 (노드 수 - 1)이 되면 종료한다.
* 음의 가중치 가능: 음수 간선이 있어도 문제 없이 동작한다.
* 그래프 조건: 무방향 그래프에서 사용한다.

# 위상 정렬 알고리즘: 선후 관계를 지키는 순서 만들기
* `#dependency`
* 방향 비순환 그래프(DAG): 사이클이 없는 방향 그래프에서만 적용 가능하다.
* 선행 조건 처리: 간선 A → B는 A가 반드시 B보다 먼저 처리되어야 함을 의미한다.
* 진입 차수(In-degree): 특정 노드로 들어오는 간선의 개수를 의미하며, 선행 작업 수와 같다.
* 시작 조건: 진입 차수가 0인 노드는 즉시 처리 가능한 노드이다.
* BFS 기반(Kahn 알고리즘): 진입 차수가 0인 노드를 큐에 넣고 하나씩 꺼내며 정렬한다.
* 간선 제거 효과: 노드를 처리하면 해당 노드에서 나가는 간선을 제거하고, 연결된 노드의 진입 차수를 감소시킨다.
* 사이클 판별: 정렬된 노드 개수가 전체 노드 수보다 적으면 사이클이 존재한다.
* 결과 다양성: 진입 차수 0인 노드가 여러 개라면 위상 정렬 결과는 여러 가지가 될 수 있다.
* 우선순위 큐 활용: 번호가 작은 노드부터 처리해야 하는 경우 PriorityQueue를 사용한다. 
* 시간 복잡도: O(V + E)